#!/usr/bin/env ruby
require 'bundler/setup'

require 'efivalidate'
require 'optparse'
require 'ostruct'


options = OpenStruct.new
options.clean = false
options.clean_me = false
options.ignore_me = true
options.verbose = true
options.efi_file = nil
options.ealf_files = [ File.join(__dir__, '../spec/fixtures/baselines/*.ealf') ]

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: efivalidate [options] <efi_file>"

  opts.separator ""
  opts.separator "Specific options:"

  opts.on("--clean", "Clear the empty EFI regions (prevents free space attacks)") do |t|
    options.clean = true
  end

  opts.on("--clean-me", "Disable the Intel ME (requires me_cleaner.py on path)") do |t|
    options.clean_me = true
  end

  opts.on("--baseline a,b,c", Array, "EALF files to use for validation") do |b|
    options.ealf_files = b.map { |f| File.expand_path(f) }
  end

  opts.on("--ignore-me", "Ignore Intel ME mismatches (useful if HAP set)") do
    options.ignore_me = true
  end

  opts.on("--verbose", "Verbose output") do
    options.verbose = true
  end
end

opt_parser.parse!(ARGV)

unless ARGV.last
  puts "No EFI file provided to parse"
  exit(-1)
end

baseline_files = options.ealf_files.flat_map { |glob| Dir.glob(glob)  }

puts "Loaded #{baseline_files.count} baseline files\n" if options.verbose

efi_file = File.expand_path(ARGV.last)
efi_data = File.open(efi_file, 'rb') { |f| f.read }


def evaluate_baseline(baseline_file, efi_data)
  data = File.open(baseline_file, 'rb') { |f| f.read }

  parser = EFIValidate::EALFParser.new(data).tap do |p|
    p.filename = File.expand_path(baseline_file)
  end

  EFIValidate::EFIValidator.new(parser, efi_data)
end

evaluators = baseline_files.map do |baseline|
  -> { evaluate_baseline(baseline, efi_data) }
end

valid_match = evaluators.find do |evaluator|
  validator = evaluator.call

  puts "Evaluating baseline #{validator.filename}" if options.verbose

  if validator.valid?
    validator
  else
    if baseline_files.count == 1
      validator.errors.each do |error|
        puts error.to_s
      end
    end

    nil
  end
end

if valid_match and options.clean
  cleaner = EFIValidate::EFICleaner(valid_match, efi_file)

  cleaner.clean!
end

puts "Valid firmware match from file #{valid_match.filename}" and exit(0) if valid_match
puts "No valid firmware baseline for #{efi_file}"
exit(1)